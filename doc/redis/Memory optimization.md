## Memory optimization（内存优化）
### 为小型数据类型特殊编码存储
从Redis 2.2开始，对许多数据类型进行了优化，以使用较少的空间来达到特定大小。
当使用哈希、列表、仅由整数组成的集合、小于给定元素数和最大元素大小时的有序集合这几种类型时，
会以一种非常节省内存的方式进行编码，该方式使用的内存减少多达10倍（平均节省5倍时间）。
从用户和API的角度来看，这是完全透明的。由于这是一种CPU/内存之间可以做权衡的方案，
因此可以使用以下redis.conf指令来调整特殊编码类型的最大元素数和最大元素大小。
````
hash-max-ziplist-entries 512
hash-max-ziplist-value 64
zset-max-ziplist-entries 128
zset-max-ziplist-value 64
set-max-intset-entries 512
````
如果被特殊编码的值超过了配置中设定的最大值，那么Redis将自动转换为普通的编码形式。
对于一些小的value来说这个转换操作是非常快的，但如果你在配置中设置了非常大的阈值，那么
建议你做以下基准测试，检验以下转换的时间。

### 使用32位的实例
使用32位编译的redis，每个key会占用比较少的空间，但指针较小，只能寻址4GB的内存。
RDB和AOF文件在32位和64位实例之间时自适应的(大端和小端同样适应)所以你可以毫无问题地切换。

### 位 和 字节级别的操作
Redis2.2介绍了一些新的位和字节的操作命令:GETRANGE, SETRANGE, GETBIT , SETBIT.
使用这些命令你可以把Redis当成一个可随机读取的数组。比如，你有一个程序，用户ID是唯一自增整数，
那么你可以通过bitmap来存储订阅了邮件的用户列表、设置某个Bit来订阅或取消订阅，或者反过来。
即使又1亿个用户，那也仅仅只使用了12M的内存。你可以通过 GETRANGE and SETRANGE来为每个用户存储bit信息。
这只是一个例子，但实际上可以使用这些新原语在很小的空间中为许多问题建模。

### 尽可能地使用hashes
小型hash使用非常少地空间，所以你应该尽可能地用hash来表示你的数据。比如你有一个网络程序，有一个表示Users
的对象,那么你不应该为name, surname, email, password等字段使用不同的key，而应该
使用一个hash，然后里面包含所有的字段。
如果想要了解更多，阅读下一部分。

###  使用Redis上的hash来抽象非常节省内存的朴素key-value存储结构

我知道这一节的标题有点吓人，但我将详细解释这是关于什么的。
基本上使用redis存储一个value是纯string的纯key-value建模不仅比redis纯key更节省内存，也比
memcached更节省内存。
让我们先确认一个事实:几个key比一个key包含几个hash字段耗费更多内存。为什么，因为我们使用了一个技巧。
理论上为了保证我们的查找是常量级别的(大O表示法标识位0(1)),我们需要一个平均常量级别的数据结构，比如哈希表。  
但是很多时候hash只会包含几个字段，当hashes很小时我们使用另一种空间为O（N）的数据结构
，比如
